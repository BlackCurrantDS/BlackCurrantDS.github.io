<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nicolas Decoopman">
<meta name="keywords" content="machine learning, résistance bactérienne, antibiotiques, diagnostic médical, génomique, IA santé">
<meta name="description" content="Projet de machine learning pour prédire la résistance bactérienne aux antibiotiques à partir de données génomiques. Analyse comparative des méthodes d’apprentissage automatique pour le diagnostic médical.">

<title>BioResistanceIA - Santé et IA, vers un diagnostic rapide de la résistance bactérienne ?</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="bioresistanceai_files/libs/clipboard/clipboard.min.js"></script>
<script src="bioresistanceai_files/libs/quarto-html/quarto.js"></script>
<script src="bioresistanceai_files/libs/quarto-html/popper.min.js"></script>
<script src="bioresistanceai_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="bioresistanceai_files/libs/quarto-html/anchor.min.js"></script>
<link href="bioresistanceai_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="bioresistanceai_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="bioresistanceai_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="bioresistanceai_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="bioresistanceai_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>
/* Masquer les métadonnées (description, auteur, mots-clés) */
.quarto-title-meta {
    display: none !important;
}

/* Masquer la description visible */
.description {
    display: none !important;
}

/* Masquer les mots-clés visibles */
.keywords {
    display: none !important;
}

.quarto-float-caption {
    text-align: center !important;
}

.intro-links {
    display: flex;
    flex-direction: column; /* titre au-dessus */
    align-items: center;
    justify-content: center;
    gap: 0.4em;
    margin-bottom: 1em;
    font-family: "Segoe UI", Roboto, sans-serif;
}

.intro-links span.title {
    font-weight: 600;
    font-size: 1.2em;
    letter-spacing: 0.02em;
}

.icon-links {
    display: flex;
    gap: 0.6em;
    align-items: center;
    justify-content: center;
}

.icon-links a svg {
    transition: transform 0.2s ease, fill 0.2s ease;
}

.icon-links a:hover svg {
    transform: scale(1.1);
    fill: #007acc;
}

.icon {
width: 24px;
height: 24px;
display: inline-block;
vertical-align: middle;
}

nav#TOC {
    text-align: left !important;
    min-width: 240px;
    max-width: 260px;
    position: fixed;
    left: 0;
    top: 0;
    height: 100vh;
    overflow-y: auto;
    background-color: #f8f9fa;
    border-right: 1px solid #ddd;
    padding: 1rem;
    font-size: 1rem;
}

/* Supprime l'espace réservé à la marge droite inutilisée */
.quarto-margin-sidebar {
    display: none !important;
}

.page-columns {
    grid-template-areas: "body" !important;
    grid-template-columns: 1fr !important;
}

main.content {
    margin-left: 280px;
    padding: 1rem;
    max-width: 80vw; /* Limite à 90% de la largeur de la fenêtre */
    box-sizing: border-box;
}

body {
    text-align: justify;
    font-size: 1rem;
    flex-direction: column;
    max-width: 80vw;
    box-sizing: border-box;
}

/* Formules MathJax responsives */
.math.display {
    display: inline-block;
    overflow-x: auto;
    white-space: nowrap;
    max-width: 100%;
}

a {
    word-break: break-word;
}

table {
    display: block;
    overflow-x: auto;
    white-space: nowrap;
    max-width: 100%;
}

@media screen and (max-width: 768px) {
    nav#TOC {
        display: none; /* Cacher la table des matières */
    }
    main.content {
        margin-left: 0;
        max-width: 98vw;
    }
    body {
        max-width: 98vw;
    }
}
</style>

<script>
document.addEventListener("DOMContentLoaded", function () {
const toc = document.querySelector("nav#TOC");
if (toc) {
    const introLinks = document.createElement("div");
    introLinks.className = "intro-links";

    introLinks.innerHTML = `
    <span class="title">{NCS}decoopman</span>
    <div class="icon-links">
        <a href="https://ncsdecoopman.github.io/" title="Accueil" aria-label="Page d'accueil">
        <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24">
            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
        </a>
        <a href="https://github.com/NCSdecoopman/BioResistanceAI" title="Voir sur GitHub" target="_blank" rel="noopener" aria-label="Voir le projet sur GitHub">
        <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24">
        <path d="M12 .5c-6.63 0-12 5.37-12 12 0 5.3 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.726-4.042-1.61-4.042-1.61-.546-1.385-1.333-1.753-1.333-1.753-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.237 1.84 1.237 1.07 1.835 2.807 1.305 3.492.998.108-.775.42-1.305.763-1.605-2.665-.305-5.466-1.332-5.466-5.932 0-1.31.468-2.382 1.235-3.222-.124-.303-.535-1.523.117-3.176 0 0 1.008-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.29-1.552 3.296-1.23 3.296-1.23.653 1.653.242 2.873.12 3.176.77.84 1.233 1.912 1.233 3.222 0 4.61-2.803 5.625-5.475 5.922.432.372.816 1.103.816 2.222 0 1.606-.015 2.896-.015 3.286 0 .322.216.694.825.576 4.765-1.586 8.2-6.085 8.2-11.385 0-6.63-5.37-12-12-12z"/>
        </svg>
        </a>
    </div>
    `;

    toc.prepend(introLinks);
}
});
</script>


<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2YTSV4PT9X"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config','G-2YTSV4PT9X', { 'anonymize_ip': true });
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Plan</h2>
   
  <ul>
  <li><a href="#contexte-et-problématique" id="toc-contexte-et-problématique" class="nav-link active" data-scroll-target="#contexte-et-problématique"><span class="header-section-number">1</span> Contexte et problématique</a></li>
  <li><a href="#données" id="toc-données" class="nav-link" data-scroll-target="#données"><span class="header-section-number">2</span> Données</a></li>
  <li><a href="#approche-et-méthodologie" id="toc-approche-et-méthodologie" class="nav-link" data-scroll-target="#approche-et-méthodologie"><span class="header-section-number">3</span> Approche et méthodologie</a>
  <ul class="collapse">
  <li><a href="#prétraitements-et-sélections" id="toc-prétraitements-et-sélections" class="nav-link" data-scroll-target="#prétraitements-et-sélections"><span class="header-section-number">3.1</span> Prétraitements et sélections</a></li>
  <li><a href="#modèles-testés" id="toc-modèles-testés" class="nav-link" data-scroll-target="#modèles-testés"><span class="header-section-number">3.2</span> Modèles testés</a></li>
  <li><a href="#evaluation-des-modèles" id="toc-evaluation-des-modèles" class="nav-link" data-scroll-target="#evaluation-des-modèles"><span class="header-section-number">3.3</span> Evaluation des modèles</a></li>
  </ul></li>
  <li><a href="#résultats" id="toc-résultats" class="nav-link" data-scroll-target="#résultats"><span class="header-section-number">4</span> Résultats</a>
  <ul class="collapse">
  <li><a href="#recall-fig.-2" id="toc-recall-fig.-2" class="nav-link" data-scroll-target="#recall-fig.-2"><span class="header-section-number">4.1</span> Recall (fig.&nbsp;2)</a></li>
  <li><a href="#sélection-des-caractéristiques-importantes-fig.-2" id="toc-sélection-des-caractéristiques-importantes-fig.-2" class="nav-link" data-scroll-target="#sélection-des-caractéristiques-importantes-fig.-2"><span class="header-section-number">4.2</span> Sélection des caractéristiques importantes (fig.&nbsp;2)</a>
  <ul class="collapse">
  <li><a href="#gpa" id="toc-gpa" class="nav-link" data-scroll-target="#gpa"><span class="header-section-number">4.2.1</span> GPA</a></li>
  <li><a href="#snps" id="toc-snps" class="nav-link" data-scroll-target="#snps"><span class="header-section-number">4.2.2</span> SNPs</a></li>
  <li><a href="#genexp" id="toc-genexp" class="nav-link" data-scroll-target="#genexp"><span class="header-section-number">4.2.3</span> GenExp</a></li>
  <li><a href="#bilan" id="toc-bilan" class="nav-link" data-scroll-target="#bilan"><span class="header-section-number">4.2.4</span> Bilan</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#technologies-utilisées" id="toc-technologies-utilisées" class="nav-link" data-scroll-target="#technologies-utilisées"><span class="header-section-number">5</span> Technologies utilisées</a></li>
  <li><a href="#difficultés-et-leçons-apprises" id="toc-difficultés-et-leçons-apprises" class="nav-link" data-scroll-target="#difficultés-et-leçons-apprises"><span class="header-section-number">6</span> Difficultés et leçons apprises</a></li>
  <li><a href="#lien-vers-le-projet" id="toc-lien-vers-le-projet" class="nav-link" data-scroll-target="#lien-vers-le-projet"><span class="header-section-number">7</span> Lien vers le projet</a></li>
  <li><a href="#cas-dusage-et-perspectives" id="toc-cas-dusage-et-perspectives" class="nav-link" data-scroll-target="#cas-dusage-et-perspectives"><span class="header-section-number">8</span> Cas d’usage et perspectives</a></li>
  <li><a href="#références" id="toc-références" class="nav-link" data-scroll-target="#références"><span class="header-section-number">9</span> Références</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">BioResistanceIA - Santé et IA, vers un diagnostic rapide de la résistance bactérienne ?</h1>
</div>

<div>
  <div class="description">
    Projet de machine learning pour prédire la résistance bactérienne aux antibiotiques à partir de données génomiques. Analyse comparative des méthodes d’apprentissage automatique pour le diagnostic médical.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Auteur·rice</div>
    <div class="quarto-title-meta-contents">
             <p>Nicolas Decoopman </p>
          </div>
  </div>
    
  
    
  </div>
  

<div>
  <div class="keywords">
    <div class="block-title">Mots clés</div>
    <p>machine learning, résistance bactérienne, antibiotiques, diagnostic médical, génomique, IA santé</p>
  </div>
</div>

</header>


<p>L’augmentation des résistances bactériennes aux antibiotiques représente un défi majeur en santé publique. Les méthodes diagnostiques basées sur la culture en laboratoire restent souvent longues et coûteuses. L’émergence de technologies permettant de prédire si une souche bactérienne est résistante ou sensible à un antibiotique à partir de données génomiques et transcriptomiques ouvre des perspectives prometteuses <span class="citation" data-cites="yang2018mltb">(<a href="#ref-yang2018mltb" role="doc-biblioref">1</a>)</span>.</p>
<section id="contexte-et-problématique" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Contexte et problématique</h1>
<p>Avec l’accessibilité croissante du séquençage génomique et la réduction continue des coûts, ces approches deviennent de plus en plus envisageables à grande échelle. Ce projet s’inscrit pleinement dans cette problématique et se concentre sur la classification binaire des phénotypes de résistance. L’intégration de données riches, mêlant variables binaires et quantitatives, permet d’analyser les bactéries sous divers angles. Cependant, cette complexité pose des défis importants en termes de prétraitement des données et de modélisation. L’objectif de cette étude est double : (i) évaluer les performances prédictives des modèles pour chacun des cinq antibiotiques étudiés ; et (ii) identifier les sources d’information les plus pertinentes pour prédire la résistance à chaque antibiotique. Pour atteindre ces objectifs, nous avons adopté une approche combinant exploration des données, sélection de modèles, optimisation des hyperparamètres et validation croisée.</p>
</section>
<section id="données" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Données</h1>
<p>L’étude porte sur 414 bactéries et s’appuie sur des données relatives aux phénotypes de sensibilité (données binaires sensible/résistant) à cinq antibiotiques (<code>pheno</code>) : la tobramycine (TOB), un aminoside ; la ceftazidime (CAZ), une céphalosporine de 3ᵉ génération (3G) ; la ciprofloxacine (CIP), une fluoroquinolone ; le méropenème (MER), un carbapénème ; et la colistine (COL), une polymyxine. Cette matrice contient 204 valeurs manquantes. La répartition pour chaque antibiotique de chaque classe est résumée dans la figure 1.</p>
<p>Le jeu de données étudié repose sur une approche intégrative combinant trois sources d’informations complémentaires : 1) la présence ou l’absence de <strong>gènes de résistance</strong> (matrice <code>X_gpa</code> de 16005 gènes), souvent associés directement à des mécanismes de résistance ; 2) la présence ou l’absence de <strong>mutations ponctuelles</strong> (SNPs) dans certains gènes (matrice <code>X_snps</code> de 72236 SNPs), susceptibles d’altérer leurs fonctions ; 3) les niveaux d’<strong>expression génique</strong> (matrice <code>X_genexp</code> de 6026 gènes), reflétant l’état cellulaire des bactéries. Ces matrices ne contiennent pas de données manquantes.</p>
<div id="cell-fig-class-distribution" class="cell" data-execution_count="2">
<div class="cell-output cell-output-display">
<div id="fig-class-distribution" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-class-distribution-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="bioresistanceai_files/figure-html/fig-class-distribution-output-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-class-distribution-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Répartition des classes par antibiotique
</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="approche-et-méthodologie" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Approche et méthodologie</h1>
<section id="prétraitements-et-sélections" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="prétraitements-et-sélections"><span class="header-section-number">3.1</span> Prétraitements et sélections</h2>
<p>Le prétraitement montre qu’il existe une variabilité génétique parmi les bactéries, probablement due à des différences dans leurs génomes ou leurs environnements. La majorité des bactéries ont entre 3500 et 4500 gènes et 14000 SNPs. Les données d’expression génique sont équilibrées et bien prétraitées pour une analyse statistique. Les bactéries ayant un nombre exceptionnellement faible de gènes ou de SNPs méritent une attention particulière, car elles pourraient représenter des cas biologiques spécifiques ou des artefacts des données.</p>
<p>Les données d’entrée ont été divisées en deux ensembles : 80 % des données ont été utilisées pour l’entraînement et l’ajustement des modèles, et 20 % pour l’évaluation finale. Une standardisation a été appliquée aux données d’expression génétique <code>X_genexp</code> pour harmoniser les échelles et optimiser la convergence des modèles. Une validation croisée à 5 plis a été appliquée sur l’ensemble d’entraînement afin de sélectionner les meilleurs hyperparamètres pour chaque classe de modèle. Pour optimiser ces hyperparamètres, nous avons utilisé une recherche par grille (<code>GridSearch</code>) sur un espace prédéfini de valeurs possibles, adaptée à chaque modèle et à chaque antibiotique. Cette approche systématique garantit que les configurations optimales des modèles sont identifiées pour maximiser leurs performances.</p>
</section>
<section id="modèles-testés" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="modèles-testés"><span class="header-section-number">3.2</span> Modèles testés</h2>
<p>L’utilisation d’une diversité de modèles permet de maximiser les chances d’identifier l’approche la plus performante pour prédire la résistance bactérienne, tout en exploitant les forces spécifiques de chaque méthode. Les modèles, du package <code>scikit-learn</code>, ont été sélectionné pour leurs capacités à gérer des données multidimensionnelles et leurs performances reconnues en classification <span class="citation" data-cites="do2024panka tang2022ml">(<a href="#ref-do2024panka" role="doc-biblioref">2</a>,<a href="#ref-tang2022ml" role="doc-biblioref">3</a>)</span>.</p>
<ol type="1">
<li><p><strong>Régression Logistique L1</strong> (<em>Lasso</em>)<br>
Ce modèle applique une régularisation L1 qui contraint certains coefficients à zéro, permettant ainsi une sélection automatique des variables. Il favorise des modèles parcimonieux et interprétables, particulièrement utiles quand on travaille avec un grand nombre de variables.</p></li>
<li><p><strong>Régression Logistique L2</strong> (<em>Ridge</em>)<br>
La régularisation L2 ne force pas les coefficients à zéro mais les contraint à rester petits, ce qui peut améliorer la généralisation tout en conservant l’ensemble des variables. Elle est plus stable lorsque de nombreuses variables sont corrélées.</p></li>
<li><p><strong>Support Vector Machine</strong> (<em>SVC</em>)<br>
Le SVM est particulièrement performant pour séparer des classes dans des espaces de grande dimension, grâce à ses fonctions noyaux. Le noyau linéaire permet une classification directe, tandis que le noyau RBF capture des relations non linéaires complexes entre les variables.</p></li>
<li><p><strong>Random Forest et XGBoost</strong><br>
Ces deux modèles, basés sur des arbres de décision, offrent une mesure d’importance des caractéristiques. Cette capacité permet d’identifier les variables les plus influentes sur les prédictions. Random Forest est robuste et adapté à la détection d’interactions non linéaires entre les variables. XGBoost est plus performant dans des contextes complexes et combine une précision élevée et une gestion efficace des interactions dans des ensembles de données volumineux.</p></li>
<li><p><strong>MLP</strong> (<em>Perceptron Multi-Couche</em>)<br>
Le MLP est un réseau de neurones supervisé, capable d’apprendre des relations non linéaires complexes. Il est moins interprétable mais offre une puissance d’apprentissage supérieure.</p></li>
<li><p><strong>LightGBM</strong> (<em>Light Gradient Boosting Machine</em>) LightGBM est un algorithme de boosting par gradient rapide et efficace, particulièrement adapté aux grands ensembles de données. Il gère les valeurs manquantes et les catégories de manière native, et fournit des scores d’importance des variables.</p></li>
</ol>
<p>Les modèles comme Random Forest, XGBoost ou LightGBM ont déjà été utilisés avec succès dans des contextes similaires <span class="citation" data-cites="arango2018deeparg">(<a href="#ref-arango2018deeparg" role="doc-biblioref">4</a>)</span>.</p>
</section>
<section id="evaluation-des-modèles" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="evaluation-des-modèles"><span class="header-section-number">3.3</span> Evaluation des modèles</h2>
<p>En comparant les performances des différents modèles, nous identifions celui qui est le plus fiable pour prédire la résistance bactérienne. La performance des modèles a été mesurée en utilisant le recall de <code>scikit-learn</code>, pour que les résultats soient facilement comparables entre antibiotiques au vu des classes déséquilibrées (figure 1).</p>
<p><span class="math display">\[
\text{Recall} = \frac{\text{Vrais positifs}}{\text{Vrais positifs} + \text{Faux négatifs}}
\]</span></p>
</section>
</section>
<section id="résultats" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Résultats</h1>
<div id="cell-fig-results" class="cell" data-execution_count="3">
<div class="cell-output cell-output-display">
<div id="fig-results" class="quarto-figure quarto-figure-center quarto-float anchored" data-fig-align="center">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-results-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="bioresistanceai_files/figure-html/fig-results-output-1.png" class="img-fluid quarto-figure quarto-figure-center figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-results-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Performances et pourcentages de variables explicatives selectionnées par différents modèles. 1) LogisticRegressionL1 : régression logistique pénalisée (Lasso). 2) LogisticRegressionL2 : régression logistique pénalisée (Ridge). 3) SVC : machines à vecteurs de support. 4) RandomForestClassifier : forêt aléatoire (ensemble de décideurs). 5) XGBClassifier : méthode de boosting par gradient extrême. 6) SkorchMLPClassifier : modèle de réseau de neurones profond. 7) LGBMClassifier : machine légère de gradient boosting
</figcaption>
</figure>
</div>
</div>
</div>
<section id="recall-fig.-2" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="recall-fig.-2"><span class="header-section-number">4.1</span> Recall (fig.&nbsp;2)</h2>
<p>L’évaluation des performances via le <strong>recall</strong> montre de fortes disparités entre antibiotiques et modèles. <strong>Tobramycine (TOB)</strong> se distingue nettement avec un <strong>recall moyen de 0,93</strong>, reflétant une excellente capacité de prédiction des résistances, notamment via <strong>XGBoost (0,96)</strong> et <strong>LGBM (0,94)</strong>. À l’inverse, <strong>Colistine (COL)</strong> reste l’antibiotique le plus difficile à modéliser, avec un <strong>score maximal à 0,77</strong> (Lasso), traduisant une complexité accrue dans la représentation des mécanismes de résistance.</p>
<p><strong>Ciprofloxacine (CIP)</strong> atteint un recall moyen élevé (<strong>0,85</strong>), bien modélisé par <strong>XGBoost et LGBM</strong>. <strong>Ceftazidime (CAZ)</strong> et <strong>Meropenem (MER)</strong> affichent des performances moyennes autour de <strong>0,80 à 0,86</strong> selon les modèles, avec des écarts notables entre approches linéaires et non linéaires.</p>
<p>D’un point de vue algorithmique, <strong>XGBoost (score moyen élevé sur tous antibiotiques)</strong> et <strong>LGBM</strong> démontrent une efficacité remarquable, suivis de près par <strong>Lasso</strong>. À l’opposé, <strong>SkorchMLPClassifier</strong> et <strong>SVC</strong> obtiennent des performances très variables et généralement inférieures (souvent &lt;0,70), notamment sur <strong>CAZ</strong>, <strong>MER</strong>, et <strong>COL</strong>.</p>
</section>
<section id="sélection-des-caractéristiques-importantes-fig.-2" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="sélection-des-caractéristiques-importantes-fig.-2"><span class="header-section-number">4.2</span> Sélection des caractéristiques importantes (fig.&nbsp;2)</h2>
<section id="gpa" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="gpa"><span class="header-section-number">4.2.1</span> GPA</h3>
<p>La matrice <strong>GPA</strong> (16 005 variables) est exploitée de manière très hétérogène. Les contributions peuvent ici dépasser <strong>50 %</strong> selon les modèles :</p>
<ul>
<li>Pour <strong>COL</strong>, <strong>Ridge</strong> et <strong>RandomForest</strong> utilisent <strong>respectivement 77,8 %</strong> et <strong>79,3 %</strong> des colonnes.<br>
</li>
<li>Pour <strong>MER</strong>, la contribution de GPA atteint <strong>63,8 %</strong> avec <strong>SVC</strong> et <strong>62,6 %</strong> avec <strong>SkorchMLPClassifier</strong>.<br>
</li>
<li>Certains modèles (comme <strong>SVC</strong>) intègre GPA de manière systématique, ce qui contraste avec le faible usage observé chez <strong>XGBoost</strong> (ex. : <strong>1,7 %</strong> pour MER).</li>
</ul>
<p>Cela montre que les modèles linéaires ou peu régularisés (ex. Ridge) ont tendance à surpondérer GPA, tandis que les modèles boostés, plus sélectifs, en limitent l’utilisation.</p>
</section>
<section id="snps" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="snps"><span class="header-section-number">4.2.2</span> SNPs</h3>
<p>Les 72 236 colonnes de la matrice <strong>SNPs</strong> sont davantage utilisées dans certains cas :</p>
<ul>
<li>Forte exploitation par <strong>RandomForest</strong> (jusqu’à <strong>78,7 %</strong> pour TOB).<br>
</li>
<li><strong>SVC</strong> et <strong>MLP</strong> peuvent aussi s’appuyer largement sur cette matrice (ex. : <strong>57 %</strong> de SNPs pour TOB avec MLP et SVC).</li>
</ul>
<p>En revanche, <strong>Lasso</strong> reste très parcimonieux (souvent &lt;30 %) pour SNPs, sauf exceptions (ex. <strong>31 %</strong> pour CIP). L’écart de contribution entre modèles linéaires et non linéaires reste donc net, notamment sur cette matrice riche mais redondante.</p>
</section>
<section id="genexp" class="level3" data-number="4.2.3">
<h3 data-number="4.2.3" class="anchored" data-anchor-id="genexp"><span class="header-section-number">4.2.3</span> GenExp</h3>
<p>La matrice <strong>GenExp</strong> (6 026 colonnes) est la plus exploitée en proportion :</p>
<ul>
<li>Pour <strong>TOB</strong>, <strong>Lasso</strong> monte jusqu’à <strong>80,9 %</strong>, et <strong>LGBM</strong> à <strong>64,7 %</strong>.<br>
</li>
<li><strong>XGBoost</strong> s’appuie également massivement sur GenExp pour <strong>MER (72,9 %)</strong> et <strong>TOB (57,5 %)</strong>.<br>
</li>
<li>Les modèles linéaires comme <strong>Lasso</strong> montrent une utilisation modérée à élevée selon l’antibiotique (jusqu’à <strong>70 %</strong> pour CAZ).<br>
</li>
<li><strong>SkorchMLPClassifier</strong> utilise aussi fortement cette matrice (jusqu’à <strong>40–50 %</strong> pour CAZ ou MER), mais de manière plus instable.</li>
</ul>
<p>En revanche, <strong>RandomForest</strong> et <strong>SVC</strong> restent souvent plus faibles sur l’utilisation de GenExp (ex. moins de <strong>4 %</strong> pour COL et CIP concernant <strong>RandomForest</strong> ; <strong>2,5 %</strong> et <strong>6,7 %</strong> pour CIP et MER concernant <strong>SVC</strong>), confirmant une sensibilité moindre aux signaux complexes contenus dans cette matrice.</p>
</section>
<section id="bilan" class="level3" data-number="4.2.4">
<h3 data-number="4.2.4" class="anchored" data-anchor-id="bilan"><span class="header-section-number">4.2.4</span> Bilan</h3>
<p><strong>GPA et SNPs</strong> sont parfois très exploités, en particulier par les modèles non linéaires (SVC, RandomForest) ou peu régularisés (Ridge). <strong>GenExp</strong> reste toutefois la <strong>matrice dominante</strong> pour les meilleurs modèles (Lasso, XGB, LGBM), surtout sur <strong>TOB</strong>, <strong>MER</strong> et <strong>CAZ</strong>.</p>
<p>Enfin, <strong>XGBoost</strong> et <strong>LGBM</strong> émergent comme les modèles les plus performants et robustes, combinant un <strong>recall élevé</strong> et une <strong>exploitation ciblée</strong> des trois sources d’information. À l’opposé, <strong>SVC</strong> et <strong>MLP</strong> montrent des limites persistantes, en particulier sur les antibiotiques difficiles comme <strong>COL</strong> ou <strong>CAZ</strong>.</p>
</section>
</section>
</section>
<section id="technologies-utilisées" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Technologies utilisées</h1>
<p>Le projet s’appuie sur un stack Python complet :</p>
<ul>
<li>le traitement et l’orchestration avec <strong>pandas</strong> et <strong>NumPy</strong><br>
</li>
<li>la modélisation combine <strong>scikit-learn</strong>, <strong>skorch</strong> et <strong>PyTorch</strong><br>
</li>
<li>les hyperparamètres sont décrits dans des fichiers <strong>YAML</strong> versionnés dans <code>config/</code>, ce qui permet de rejouer facilement les expériences</li>
</ul>
</section>
<section id="difficultés-et-leçons-apprises" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Difficultés et leçons apprises</h1>
<p>Le projet a mis en lumière plusieurs défis liés au traitement de données biologiques massives et hétérogènes. L’un des principaux obstacles a été la haute dimension des matrices d’entrée : plus de 72 000 SNPs, 16 000 gènes de résistance et 6 000 expressions géniques. Cette complexité a nécessité un prétraitement rigoureux, une standardisation soignée et une gestion efficace de la mémoire. Certains modèles comme SVC ou MLP se sont révélés sensibles au choix des hyperparamètres, avec des performances très variables sans calibration fine. Cela a souligné l’importance d’un pipeline de recherche d’hyperparamètres systématique (via GridSearchCV) et reproductible. Enfin, le choix du recall comme métrique principale s’est révélé crucial pour évaluer les performances dans un contexte de classes déséquilibrées, évitant une surestimation des modèles favorisant la classe majoritaire. Ce projet a ainsi renforcé la nécessité d’une approche à la fois exploratoire, méthodique et adaptée à la structure des données pour bâtir des modèles robustes et interprétables.</p>
</section>
<section id="lien-vers-le-projet" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Lien vers le projet</h1>
<p>Le code source est accessible sur GitHub : <a href="https://github.com/NCSdecoopman/BioResistanceAI">https://github.com/NCSdecoopman/BioResistanceAI</a></p>
</section>
<section id="cas-dusage-et-perspectives" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Cas d’usage et perspectives</h1>
<p>Le machine learning prédit efficacement la résistance bactérienne à partir de données multi-omiques. Les modèles boosting (XGBoost, LGBM) et la régression pénalisée se révèlent les plus précis et stables, surtout avec les profils transcriptomiques ; les SNPs offrent un gain secondaire, tandis que les matrices GPA apportent peu. SVC et MLP restent en retrait faute de tuning approfondi, mais pourraient progresser. Un pipeline mélangeant boosting et régression pénalisée, associé à un réglage automatique des hyperparamètres, apparaît donc comme la solution la plus prometteuse pour un diagnostic rapide en contexte clinique.</p>
</section>
<section id="références" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> Références</h1>
<div id="refs" class="references csl-bib-body" role="list">
<div id="ref-yang2018mltb" class="csl-entry" role="listitem">
<div class="csl-left-margin">1. </div><div class="csl-right-inline">Yang Y, Niehaus KE, Walker TM, Iqbal Z, Walker AS, Wilson DJ, et al. <a href="https://doi.org/10.1093/bioinformatics/btx801">Machine Learning for Classifying Tuberculosis Drug-Resistance from DNA Sequencing Data</a>. Bioinformatics. 2018;34(10):1666‑71. </div>
</div>
<div id="ref-do2024panka" class="csl-entry" role="listitem">
<div class="csl-left-margin">2. </div><div class="csl-right-inline">Do VH, Nguyen VS, Nguyen SH, Le DQ, Nguyen TT, Nguyen CH, et al. <a href="https://doi.org/10.1016/j.isci.2024.110623">PanKA: Leveraging Population Pangenome to Predict Antibiotic Resistance</a>. iScience. 2024;27(9):110623. </div>
</div>
<div id="ref-tang2022ml" class="csl-entry" role="listitem">
<div class="csl-left-margin">3. </div><div class="csl-right-inline">Tang R, Luo R, Tang S, Song H, Chen X. <a href="https://doi.org/10.1016/j.ijantimicag.2022.106684">Machine Learning in Predicting Antimicrobial Resistance: A Systematic Review and Meta-Analysis</a>. International Journal of Antimicrobial Agents. 2022;60(5–6):106684. </div>
</div>
<div id="ref-arango2018deeparg" class="csl-entry" role="listitem">
<div class="csl-left-margin">4. </div><div class="csl-right-inline">Arango-Argoty G, Garner E, Pruden A, Heath LS, Vikesland P, Zhang L. <a href="https://doi.org/10.1186/s40168-018-0401-z">DeepARG: a Deep Learning Approach for Predicting Antibiotic Resistance Genes from Metagenomic Data</a>. Microbiome. 2018;6(1):23. </div>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copié");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copié");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>