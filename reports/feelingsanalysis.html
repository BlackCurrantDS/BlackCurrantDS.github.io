<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Nicolas Decoopman">
<meta name="keywords" content="NLP, sentiment analysis, classification multi-aspects, camembert, fine-tuning, PyTorch Lightning, transformers, analyse de sentiments, avis restaurants">
<meta name="description" content="Projet de fine-tuning de modèles de langage pré-entraînés pour la classification multi-aspects de sentiments sur des avis de restaurants en français. Analyse comparative des approches LLM zero-shot et PLM fine-tuning avec CamemBERT-Large.">

<title>FeelingsAnalysis - Classification de sentiments pour avis de restaurants</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="feelingsanalysis_files/libs/clipboard/clipboard.min.js"></script>
<script src="feelingsanalysis_files/libs/quarto-html/quarto.js"></script>
<script src="feelingsanalysis_files/libs/quarto-html/popper.min.js"></script>
<script src="feelingsanalysis_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="feelingsanalysis_files/libs/quarto-html/anchor.min.js"></script>
<link href="feelingsanalysis_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="feelingsanalysis_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="feelingsanalysis_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="feelingsanalysis_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="feelingsanalysis_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<style>
/* Masquer les métadonnées (description, auteur, mots-clés) */
.quarto-title-meta {
    display: none !important;
}

/* Masquer la description visible */
.description {
    display: none !important;
}

/* Masquer les mots-clés visibles */
.keywords {
    display: none !important;
}

.quarto-float-caption {
    text-align: center !important;
}

.intro-links {
    display: flex;
    flex-direction: column; /* titre au-dessus */
    align-items: center;
    justify-content: center;
    gap: 0.4em;
    margin-bottom: 1em;
    font-family: "Segoe UI", Roboto, sans-serif;
}

.intro-links span.title {
    font-weight: 600;
    font-size: 1.2em;
    letter-spacing: 0.02em;
}

.icon-links {
    display: flex;
    gap: 0.6em;
    align-items: center;
    justify-content: center;
}

.icon-links a svg {
    transition: transform 0.2s ease, fill 0.2s ease;
}

.icon-links a:hover svg {
    transform: scale(1.1);
    fill: #007acc;
}

.icon {
width: 24px;
height: 24px;
display: inline-block;
vertical-align: middle;
}

nav#TOC {
    text-align: left !important;
    min-width: 240px;
    max-width: 260px;
    position: fixed;
    left: 0;
    top: 0;
    height: 100vh;
    overflow-y: auto;
    background-color: #f8f9fa;
    border-right: 1px solid #ddd;
    padding: 1rem;
    font-size: 1rem;
}

/* Supprime l'espace réservé à la marge droite inutilisée */
.quarto-margin-sidebar {
    display: none !important;
}

.page-columns {
    grid-template-areas: "body" !important;
    grid-template-columns: 1fr !important;
}

main.content {
    margin-left: 280px;
    padding: 1rem;
    max-width: 80vw; /* Limite à 90% de la largeur de la fenêtre */
    box-sizing: border-box;
}

body {
    text-align: justify;
    font-size: 1rem;
    flex-direction: column;
    max-width: 80vw;
    box-sizing: border-box;
}

/* Formules MathJax responsives */
.math.display {
    display: inline-block;
    overflow-x: auto;
    white-space: nowrap;
    max-width: 100%;
}

a {
    word-break: break-word;
}

table {
    display: block;
    overflow-x: auto;
    white-space: nowrap;
    max-width: 100%;
}

@media screen and (max-width: 768px) {
    nav#TOC {
        display: none; /* Cacher la table des matières */
    }
    main.content {
        margin-left: 0;
        max-width: 98vw;
    }
    body {
        max-width: 98vw;
    }
}
</style>

<script>
document.addEventListener("DOMContentLoaded", function () {
const toc = document.querySelector("nav#TOC");
if (toc) {
    const introLinks = document.createElement("div");
    introLinks.className = "intro-links";

    introLinks.innerHTML = `
    <span class="title">{NCS}decoopman</span>
    <div class="icon-links">
        <a href="https://ncsdecoopman.github.io/" title="Accueil" aria-label="Page d'accueil">
        <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24">
            <path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/>
        </svg>
        </a>
        <a href="https://github.com/NCSdecoopman/FeelingsAnalysis" title="Voir sur GitHub" target="_blank" rel="noopener" aria-label="Voir le projet sur GitHub">
        <svg class="icon" xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 24 24">
        <path d="M12 .5c-6.63 0-12 5.37-12 12 0 5.3 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.726-4.042-1.61-4.042-1.61-.546-1.385-1.333-1.753-1.333-1.753-1.09-.745.083-.73.083-.73 1.205.085 1.84 1.237 1.84 1.237 1.07 1.835 2.807 1.305 3.492.998.108-.775.42-1.305.763-1.605-2.665-.305-5.466-1.332-5.466-5.932 0-1.31.468-2.382 1.235-3.222-.124-.303-.535-1.523.117-3.176 0 0 1.008-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.29-1.552 3.296-1.23 3.296-1.23.653 1.653.242 2.873.12 3.176.77.84 1.233 1.912 1.233 3.222 0 4.61-2.803 5.625-5.475 5.922.432.372.816 1.103.816 2.222 0 1.606-.015 2.896-.015 3.286 0 .322.216.694.825.576 4.765-1.586 8.2-6.085 8.2-11.385 0-6.63-5.37-12-12-12z"/>
        </svg>
        </a>
    </div>
    `;

    toc.prepend(introLinks);
}
});
</script>


<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-2YTSV4PT9X"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config','G-2YTSV4PT9X', { 'anonymize_ip': true });
</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Plan</h2>
   
  <ul>
  <li><a href="#contexte-et-problématique" id="toc-contexte-et-problématique" class="nav-link active" data-scroll-target="#contexte-et-problématique"><span class="header-section-number">1</span> Contexte et problématique</a></li>
  <li><a href="#données" id="toc-données" class="nav-link" data-scroll-target="#données"><span class="header-section-number">2</span> Données</a></li>
  <li><a href="#approche-et-méthodologie" id="toc-approche-et-méthodologie" class="nav-link" data-scroll-target="#approche-et-méthodologie"><span class="header-section-number">3</span> Approche et méthodologie</a>
  <ul class="collapse">
  <li><a href="#deux-approches-complémentaires" id="toc-deux-approches-complémentaires" class="nav-link" data-scroll-target="#deux-approches-complémentaires"><span class="header-section-number">3.1</span> Deux approches complémentaires</a>
  <ul class="collapse">
  <li><a href="#llm-zero-shot-ollama" id="toc-llm-zero-shot-ollama" class="nav-link" data-scroll-target="#llm-zero-shot-ollama"><span class="header-section-number">3.1.1</span> LLM Zero-Shot (Ollama)</a></li>
  <li><a href="#plmft-pre-trained-language-model-fine-tuning" id="toc-plmft-pre-trained-language-model-fine-tuning" class="nav-link" data-scroll-target="#plmft-pre-trained-language-model-fine-tuning"><span class="header-section-number">3.1.2</span> PLMFT (Pre-trained Language Model Fine-Tuning)</a></li>
  </ul></li>
  <li><a href="#optimisations-implémentées" id="toc-optimisations-implémentées" class="nav-link" data-scroll-target="#optimisations-implémentées"><span class="header-section-number">3.2</span> Optimisations implémentées</a></li>
  <li><a href="#pipeline-dentraînement" id="toc-pipeline-dentraînement" class="nav-link" data-scroll-target="#pipeline-dentraînement"><span class="header-section-number">3.3</span> Pipeline d’entraînement</a></li>
  </ul></li>
  <li><a href="#résultats" id="toc-résultats" class="nav-link" data-scroll-target="#résultats"><span class="header-section-number">4</span> Résultats</a>
  <ul class="collapse">
  <li><a href="#performances-par-aspect" id="toc-performances-par-aspect" class="nav-link" data-scroll-target="#performances-par-aspect"><span class="header-section-number">4.1</span> Performances par aspect</a></li>
  <li><a href="#historique-des-expériences" id="toc-historique-des-expériences" class="nav-link" data-scroll-target="#historique-des-expériences"><span class="header-section-number">4.2</span> Historique des expériences</a></li>
  </ul></li>
  <li><a href="#technologies-utilisées" id="toc-technologies-utilisées" class="nav-link" data-scroll-target="#technologies-utilisées"><span class="header-section-number">5</span> Technologies utilisées</a></li>
  <li><a href="#difficultés-et-leçons-apprises" id="toc-difficultés-et-leçons-apprises" class="nav-link" data-scroll-target="#difficultés-et-leçons-apprises"><span class="header-section-number">6</span> Difficultés et leçons apprises</a>
  <ul class="collapse">
  <li><a href="#gestion-de-la-mémoire-gpu" id="toc-gestion-de-la-mémoire-gpu" class="nav-link" data-scroll-target="#gestion-de-la-mémoire-gpu"><span class="header-section-number">6.1</span> Gestion de la mémoire GPU</a></li>
  <li><a href="#équilibrage-des-hyperparamètres" id="toc-équilibrage-des-hyperparamètres" class="nav-link" data-scroll-target="#équilibrage-des-hyperparamètres"><span class="header-section-number">6.2</span> Équilibrage des hyperparamètres</a></li>
  <li><a href="#gestion-du-déséquilibre-des-classes" id="toc-gestion-du-déséquilibre-des-classes" class="nav-link" data-scroll-target="#gestion-du-déséquilibre-des-classes"><span class="header-section-number">6.3</span> Gestion du déséquilibre des classes</a></li>
  <li><a href="#pipeline-reproductible" id="toc-pipeline-reproductible" class="nav-link" data-scroll-target="#pipeline-reproductible"><span class="header-section-number">6.4</span> Pipeline reproductible</a></li>
  </ul></li>
  <li><a href="#lien-vers-le-projet" id="toc-lien-vers-le-projet" class="nav-link" data-scroll-target="#lien-vers-le-projet"><span class="header-section-number">7</span> Lien vers le projet</a></li>
  <li><a href="#cas-dusage-et-perspectives" id="toc-cas-dusage-et-perspectives" class="nav-link" data-scroll-target="#cas-dusage-et-perspectives"><span class="header-section-number">8</span> Cas d’usage et perspectives</a>
  <ul class="collapse">
  <li><a href="#applications-pratiques" id="toc-applications-pratiques" class="nav-link" data-scroll-target="#applications-pratiques"><span class="header-section-number">8.1</span> Applications pratiques</a></li>
  <li><a href="#pistes-damélioration" id="toc-pistes-damélioration" class="nav-link" data-scroll-target="#pistes-damélioration"><span class="header-section-number">8.2</span> Pistes d’amélioration</a></li>
  <li><a href="#généralisation" id="toc-généralisation" class="nav-link" data-scroll-target="#généralisation"><span class="header-section-number">8.3</span> Généralisation</a></li>
  </ul></li>
  <li><a href="#références" id="toc-références" class="nav-link" data-scroll-target="#références"><span class="header-section-number">9</span> Références</a></li>
  </ul>
</nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">FeelingsAnalysis - Classification de sentiments pour avis de restaurants</h1>
</div>

<div>
  <div class="description">
    Projet de fine-tuning de modèles de langage pré-entraînés pour la classification multi-aspects de sentiments sur des avis de restaurants en français. Analyse comparative des approches LLM zero-shot et PLM fine-tuning avec CamemBERT-Large.
  </div>
</div>


<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Auteur·rice</div>
    <div class="quarto-title-meta-contents">
             <p>Nicolas Decoopman </p>
          </div>
  </div>
    
  
    
  </div>
  

<div>
  <div class="keywords">
    <div class="block-title">Mots clés</div>
    <p>NLP, sentiment analysis, classification multi-aspects, camembert, fine-tuning, PyTorch Lightning, transformers, analyse de sentiments, avis restaurants</p>
  </div>
</div>

</header>


<p>L’analyse de sentiments est devenue un enjeu majeur pour les entreprises cherchant à comprendre les opinions de leurs clients. Dans le secteur de la restauration, les avis en ligne constituent une source d’information précieuse mais complexe à traiter, car ils expriment souvent des opinions nuancées sur plusieurs aspects d’une même expérience (qualité des plats, service, ambiance, rapport qualité-prix).</p>
<section id="contexte-et-problématique" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Contexte et problématique</h1>
<p>Ce projet s’inscrit dans le cadre d’un défi académique visant à développer un système de classification multi-aspects de sentiments pour des avis de restaurants en français. Contrairement à une classification de sentiment simple (positif/négatif), l’objectif est d’identifier précisément l’opinion exprimée sur <strong>quatre aspects distincts</strong> : le <strong>prix</strong>, la <strong>cuisine</strong>, le <strong>service</strong> et l’<strong>ambiance</strong>. Pour chaque aspect, le système doit déterminer si l’opinion est <strong>positive</strong>, <strong>négative</strong>, <strong>neutre</strong> ou <strong>non Exprimée (NE)</strong>.</p>
<p>Cette tâche présente plusieurs défis : (i) la nature multi-sortie du problème (4 classifications indépendantes) ; (ii) la gestion des classes déséquilibrées ; (iii) l’optimisation des performances avec des ressources GPU limitées ; et (iv) la nécessité d’atteindre un score d’exactitude d’au moins 85% pour être compétitif. Pour relever ces défis, deux approches ont été explorées : l’utilisation de modèles de langage (LLM) en mode zero-shot via Ollama, et le fine-tuning de modèles pré-entraînés (PLMFT) avec CamemBERT-Large <span class="citation" data-cites="camembert2020">(<a href="#ref-camembert2020" role="doc-biblioref">1</a>)</span>.</p>
</section>
<section id="données" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Données</h1>
<p>Le jeu de données utilisé est composé de trois fichiers TSV (Tab-Separated Values) : <code>ftdataset_train.tsv</code> (entraînement), <code>ftdataset_val.tsv</code> (validation) et <code>ftdataset_test.tsv</code> (test). Chaque fichier contient des avis de restaurants en français avec les colonnes suivantes :</p>
<table class="table">
<thead>
<tr class="header">
<th>Colonne</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Avis</code></td>
<td>Texte de l’avis client</td>
</tr>
<tr class="even">
<td><code>Prix</code></td>
<td>Sentiment sur le prix (Positive/Négative/Neutre/NE)</td>
</tr>
<tr class="odd">
<td><code>Cuisine</code></td>
<td>Sentiment sur la qualité de la cuisine</td>
</tr>
<tr class="even">
<td><code>Service</code></td>
<td>Sentiment sur le service</td>
</tr>
<tr class="odd">
<td><code>Ambiance</code></td>
<td>Sentiment sur l’ambiance</td>
</tr>
</tbody>
</table>
<p>Les données présentent les caractéristiques suivantes :</p>
<ul>
<li>Classification multi-sortie : 4 tâches de classification indépendantes par avis</li>
<li>4 classes par aspect : positive, négative, neutre, NE (non exprimé)</li>
<li>Déséquilibre potentiel : La classe “NE” peut être sur-représentée pour certains aspects</li>
<li>Langue : Français exclusivement, nécessitant l’utilisation de modèles adaptés CamemBERT <span class="citation" data-cites="camembert2020">(<a href="#ref-camembert2020" role="doc-biblioref">1</a>)</span></li>
</ul>
</section>
<section id="approche-et-méthodologie" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Approche et méthodologie</h1>
<section id="deux-approches-complémentaires" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="deux-approches-complémentaires"><span class="header-section-number">3.1</span> Deux approches complémentaires</h2>
<section id="llm-zero-shot-ollama" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="llm-zero-shot-ollama"><span class="header-section-number">3.1.1</span> LLM Zero-Shot (Ollama)</h3>
<p>La première approche exploite des modèles de langage de grande taille (LLM) en mode zero-shot, sans entraînement spécifique. Un prompt structuré en français est envoyé au modèle via Ollama, demandant de classifier l’avis selon les 4 aspects. Le modèle retourne une réponse au format JSON qui est ensuite parsée.</p>
<p><strong>Avantages</strong> : Aucun entraînement nécessaire, facilité de mise en œuvre<br>
<strong>Limites</strong> : Fragilité du parsing JSON, performances variables, lenteur du traitement</p>
</section>
<section id="plmft-pre-trained-language-model-fine-tuning" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="plmft-pre-trained-language-model-fine-tuning"><span class="header-section-number">3.1.2</span> PLMFT (Pre-trained Language Model Fine-Tuning)</h3>
<p>La seconde approche, qui s’est révélée la plus performante, consiste à fine-tuner le modèle <strong>CamemBERT-Large</strong> (110M paramètres, <span class="citation" data-cites="camembert2020">(<a href="#ref-camembert2020" role="doc-biblioref">1</a>)</span>) sur nos données spécifiques. L’architecture mise en place utilise :</p>
<ul>
<li>Backbone : CamemBERT-Large pré-entraîné sur du texte français</li>
<li>4 têtes de classification indépendantes : Une couche linéaire par aspect</li>
<li>Pooling : Extraction du token [CLS] comme représentation de la phrase</li>
<li>Loss : CrossEntropyLoss avec label smoothing (0.1) pour réduire l’overfitting</li>
</ul>
</section>
</section>
<section id="optimisations-implémentées" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="optimisations-implémentées"><span class="header-section-number">3.2</span> Optimisations implémentées</h2>
<p>Pour maximiser les performances tout en respectant les contraintes GPU, plusieurs optimisations ont été déployées :</p>
<ol type="1">
<li>Gradient Checkpointing : réduit l’utilisation mémoire GPU de ~40%</li>
<li>Mixed Precision Training (FP16) : accélération ~2-3x de l’entraînement</li>
<li>Discriminative Learning Rates : taux d’apprentissage différencié entre le backbone (<span class="math inline">\(1e-5\)</span>) et les têtes de classification (<span class="math inline">\(2e-5\)</span>)</li>
<li>Label Smoothing (0.1) : régularisation pour améliorer la généralisation</li>
<li>Gradient Accumulation (×4) : simule des batchs plus larges (batch effectif = 128)</li>
<li>Warmup + Linear Scheduler : stabilise l’entraînement avec 1000 steps de warmup</li>
<li>Early Stopping (patience=3) : arrêt automatique si pas d’amélioration sur la validation</li>
<li>DataLoader optimisé : <code>num_workers=8</code>, <code>pin_memory=True</code>, <code>persistent_workers=True</code></li>
</ol>
</section>
<section id="pipeline-dentraînement" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="pipeline-dentraînement"><span class="header-section-number">3.3</span> Pipeline d’entraînement</h2>
<p>Le pipeline d’entraînement s’appuie sur <strong>PyTorch Lightning</strong>, garantissant reproductibilité et modularité :</p>
<ol type="1">
<li>Préparation des données : chargement des fichiers TSV et création de <code>AspectDataset</code></li>
<li>Tokenization : utilisation du tokenizer CamemBERT avec <code>max_length=256</code></li>
<li>Entraînement : fine-tuning avec validation croisée</li>
<li>Évaluation : calcul de l’accuracy par aspect et macro-accuracy</li>
<li>Logging : sauvegarde automatique des métriques dans <code>lightning_logs/</code></li>
</ol>
<p>L’ensemble du processus est orchestré par <code>runproject.py</code>, qui permet de lancer facilement des expériences avec différents hyperparamètres via des arguments CLI (device, batch_size, learning_rate, etc.).</p>
</section>
</section>
<section id="résultats" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Résultats</h1>
<p>Les expériences menées ont permis d’atteindre des performances solides, avec une <strong>macro-accuracy de 85.99%</strong> sur l’ensemble de validation.</p>
<section id="performances-par-aspect" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="performances-par-aspect"><span class="header-section-number">4.1</span> Performances par aspect</h2>
<table class="table">
<thead>
<tr class="header">
<th>Aspect</th>
<th>Val Accuracy</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Prix</strong></td>
<td><strong>86.7%</strong></td>
</tr>
<tr class="even">
<td><strong>Cuisine</strong></td>
<td><strong>87.2%</strong></td>
</tr>
<tr class="odd">
<td><strong>Service</strong></td>
<td><strong>87.8%</strong></td>
</tr>
<tr class="even">
<td><strong>Ambiance</strong></td>
<td><strong>82.3%</strong></td>
</tr>
<tr class="odd">
<td><strong>Moyenne</strong></td>
<td><strong>85.99%</strong></td>
</tr>
</tbody>
</table>
<p>Le service est l’aspect le mieux prédit (87.8%), suivi de la cuisine (87.2%) et du prix (86.7%). L’ambiance reste légèrement en retrait (82.3%), probablement en raison d’une plus grande variabilité dans les expressions utilisées pour décrire cet aspect.</p>
</section>
<section id="historique-des-expériences" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="historique-des-expériences"><span class="header-section-number">4.2</span> Historique des expériences</h2>
<p>Au total, <strong>24+ versions d’expériences</strong> ont été menées avec différentes combinaisons d’hyperparamètres. Les logs détaillés sont disponibles dans <code>src/lightning_logs/</code>, permettant de comparer :</p>
<ul>
<li>Les courbes de loss (train/validation)</li>
<li>Les métriques par aspect</li>
<li>Les temps d’entraînement</li>
<li>L’impact des différents hyperparamètres</li>
</ul>
<p>L’analyse de ces expériences a permis d’identifier la configuration optimale retenue dans <code>config.py</code>.</p>
</section>
</section>
<section id="technologies-utilisées" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Technologies utilisées</h1>
<p>Le projet repose sur un écosystème Python moderne et éprouvé :</p>
<p><strong>Deep Learning</strong><br>
- <code>torch&gt;=2.0.0</code> : Framework de deep learning - <code>lightning&gt;=2.0.0</code> : Entraînement structuré et reproductible - <code>transformers&gt;=4.30.0</code> : Accès aux modèles pré-entraînés (CamemBERT, <span class="citation" data-cites="camembert2020">(<a href="#ref-camembert2020" role="doc-biblioref">1</a>)</span>)</p>
<p><strong>Traitement de données</strong><br>
- <code>pandas&gt;=2.0.0</code> : Manipulation des fichiers TSV - <code>numpy&gt;=1.24.0</code> : Calculs numériques</p>
<p><strong>Configuration et CLI</strong><br>
- <code>pyrallis&gt;=0.3.0</code> : Parsing élégant des arguments avec dataclasses - <code>pyyaml&gt;=6.0</code> : Configuration au format YAML</p>
<p><strong>LLM (optionnel)</strong><br>
- <code>ollama&gt;=0.1.0</code> : Interface pour l’approche zero-shot - <code>jinja2&gt;=3.1.0</code> : Templates de prompts</p>
<p><strong>Évaluation</strong><br>
- <code>scikit-learn&gt;=1.3.0</code> : Métriques d’évaluation - <code>tqdm&gt;=4.65.0</code> : Barres de progression</p>
<p>L’ensemble forme un stack cohérent, bien documenté et maintenu par la communauté scientifique et industrielle.</p>
</section>
<section id="difficultés-et-leçons-apprises" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Difficultés et leçons apprises</h1>
<section id="gestion-de-la-mémoire-gpu" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="gestion-de-la-mémoire-gpu"><span class="header-section-number">6.1</span> Gestion de la mémoire GPU</h2>
<p>Le fine-tuning de CamemBERT-Large (110M paramètres, <span class="citation" data-cites="camembert2020">(<a href="#ref-camembert2020" role="doc-biblioref">1</a>)</span>) sur GPU a nécessité une optimisation poussée de l’utilisation mémoire. Les erreurs <code>CUDA Out Of Memory</code> ont été fréquentes dans les premières expériences. L’activation du gradient checkpointing et l’utilisation de mixed precision training ont été déterminantes pour permettre l’entraînement avec des batch sizes raisonnables.</p>
</section>
<section id="équilibrage-des-hyperparamètres" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="équilibrage-des-hyperparamètres"><span class="header-section-number">6.2</span> Équilibrage des hyperparamètres</h2>
<p>Trouver le bon équilibre entre learning rate du backbone et des têtes de classification s’est révélé crucial. Un learning rate trop élevé sur le backbone entraînait un “catastrophic forgetting” (le modèle oubliait ses connaissances pré-entraînées), tandis qu’un learning rate trop faible ralentissait la convergence.</p>
</section>
<section id="gestion-du-déséquilibre-des-classes" class="level2" data-number="6.3">
<h2 data-number="6.3" class="anchored" data-anchor-id="gestion-du-déséquilibre-des-classes"><span class="header-section-number">6.3</span> Gestion du déséquilibre des classes</h2>
<p>La classe “NE” (Non Exprimé) étant potentiellement sur-représentée, l’utilisation de label smoothing a permis de réduire la sur-confiance du modèle sur cette classe majoritaire et d’améliorer la généralisation.</p>
</section>
<section id="pipeline-reproductible" class="level2" data-number="6.4">
<h2 data-number="6.4" class="anchored" data-anchor-id="pipeline-reproductible"><span class="header-section-number">6.4</span> Pipeline reproductible</h2>
<p>La mise en place d’un système de configuration centralisé (<code>config.py</code>) et l’utilisation de PyTorch Lightning <span class="citation" data-cites="pytorch2019">(<a href="#ref-lightning2019" role="doc-biblioref">3</a>)</span> ont grandement facilité la reproductibilité des expériences. Chaque run est loggé automatiquement avec ses hyperparamètres, permettant de tracer précisément les améliorations entre versions.</p>
</section>
</section>
<section id="lien-vers-le-projet" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Lien vers le projet</h1>
<p>Le code source est accessible sur GitHub : <a href="https://github.com/NCSdecoopman/FeelingsAnalysis">https://github.com/NCSdecoopman/FeelingsAnalysis</a></p>
</section>
<section id="cas-dusage-et-perspectives" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Cas d’usage et perspectives</h1>
<section id="applications-pratiques" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="applications-pratiques"><span class="header-section-number">8.1</span> Applications pratiques</h2>
<p>Ce système de classification multi-aspects trouve des applications directes dans :</p>
<ul>
<li>Analyse de réputation en ligne : les restaurateurs peuvent identifier précisément les points forts et faibles de leur établissement</li>
<li>Recommandation personnalisée : suggérer des restaurants en fonction des préférences aspect par aspect</li>
<li>Monitoring temps réel : détecter rapidement une dégradation sur un aspect spécifique (ex: service)</li>
<li>Benchmarking concurrentiel : comparer les performances sur chaque dimension</li>
</ul>
</section>
<section id="pistes-damélioration" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="pistes-damélioration"><span class="header-section-number">8.2</span> Pistes d’amélioration</h2>
<p>Plusieurs axes d’amélioration sont envisageables :</p>
<ol type="1">
<li><strong>Ensembling</strong> : combiner les prédictions de plusieurs modèles (XGBoost + LGBM sur features linguistiques + CamemBERT)</li>
<li><strong>Data augmentation</strong> : augmenter artificiellement les données d’entraînement (paraphrase, back-translation)</li>
<li><strong>Architecture avancée</strong> : tester des modèles plus récents (DeBERTa, mBART, RoBERTa-large français)</li>
<li><strong>Attention multi-aspects</strong> : intégrer un mécanisme d’attention croisée entre les 4 têtes pour capturer les interactions entre aspects</li>
<li><strong>Distillation</strong> : créer un modèle plus léger (CamemBERT-base) pour le déploiement en production</li>
<li><strong>Interface interactive</strong> : développer une API REST ou une interface web pour des tests en temps réel</li>
</ol>
</section>
<section id="généralisation" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="généralisation"><span class="header-section-number">8.3</span> Généralisation</h2>
<p>L’approche développée est transposable à d’autres domaines nécessitant une analyse fine d’opinions :</p>
<ul>
<li>Avis produits e-commerce (qualité, prix, livraison, SAV)</li>
<li>Enquêtes de satisfaction client (plusieurs dimensions)</li>
<li>Analyse de feedback employés (environnement, management, rémunération)</li>
</ul>
</section>
</section>
<section id="références" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> Références</h1>
<div id="refs" class="references csl-bib-body" role="list">
<div id="ref-camembert2020" class="csl-entry" role="listitem">
<div class="csl-left-margin">1. </div><div class="csl-right-inline">Martin L, Muller B, Suárez PJO, Dupont Y, Romary L, Clergerie É de la, et al. CamemBERT: a Tasty French Language Model. arXiv preprint arXiv:191103894. 2019; </div>
</div>
<div id="ref-pytorch2019" class="csl-entry" role="listitem">
<div class="csl-left-margin">2. </div><div class="csl-right-inline">Paszke A, Gross S, Massa F, Lerer A, Bradbury J, Chanan G, et al. PyTorch: An Imperative Style, High-Performance Deep Learning Library. In: Advances in Neural Information Processing Systems. 2019. p. 8026‑37. </div>
</div>
<div id="ref-lightning2019" class="csl-entry" role="listitem">
<div class="csl-left-margin">3. </div><div class="csl-right-inline">Falcon W, The PyTorch Lightning team. PyTorch Lightning. GitHub Note: https://githubcom/PyTorchLightning/pytorch-lightning. 2019;3. </div>
</div>
</div>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copié");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copié");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>